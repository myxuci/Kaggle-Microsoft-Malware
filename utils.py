import gc
import time
from tqdm import tqdm
from numba import jit
import numpy as np
import pandas as pd
from contextlib import contextmanager

@jit
def filter_unique_ele_in_train(train, test, col, suffix='_filtered'):
    # assert col in train.columns and col in test.columns, ValueError('col is absent in either train or test.')
    new_col_name = col + suffix
    # print('Working on column of {}...'.format(col))
    test_col_unique_ele = test[col].unique().tolist()
    test_col_unique_ele_df = pd.DataFrame({col:test_col_unique_ele, new_col_name:test_col_unique_ele})
    output = train[col].to_frame().merge(test_col_unique_ele_df, how='left')

    # Double check:
    assert output.shape[0] == train.shape[0]

    return output, new_col_name

@jit
def change_unique_ele_in_train(train, test, vars_to_skip=['MachineIdentifier','HasDetections'], suffix='_filtered', inplace=True):
    _tic = time.time()
    vars_to_skip = [vars_to_skip] if not isinstance(vars_to_skip, list) else vars_to_skip
    for col in vars_to_skip:
        assert col in train.columns, ValueError('Column of {} does not exist in train...'.format(col))

    for col in tqdm(train.columns.tolist(), total=train.shape[1] - len(vars_to_skip)):
        if col in vars_to_skip:
            print('Skip column of {}...'.format(col))
            continue
        else:
            _proc_col_data, _new_col_name = filter_unique_ele_in_train(train, test, col, suffix=suffix)
            if inplace:
                train[col] = _proc_col_data[_new_col_name]
            else:
                train[_new_col_name] = _proc_col_data[_new_col_name]
                train.drop(col, axis=1, inplace=True)
            gc.collect()
    print('Time cost: {:.2f} minute(s)'.format((time.time()-_tic)/60.0))
    return train

def add_noise(series, noise_level):
    return series * (1 + noise_level * np.random.randn(len(series)))
def target_encode(trn_series=None, 
                  tst_series=None, 
                  target=None, 
                  min_samples_leaf=1, 
                  smoothing=1,
                  noise_level=0):
    """
    Smoothing is computed like in the following paper by Daniele Micci-Barreca
    https://kaggle2.blob.core.windows.net/forum-message-attachments/225952/7441/high%20cardinality%20categoricals.pdf
    trn_series : training categorical feature as a pd.Series
    tst_series : test categorical feature as a pd.Series
    target : target data as a pd.Series
    min_samples_leaf (int) : minimum samples to take category average into account
    smoothing (int) : smoothing effect to balance categorical average vs prior  
    """ 
    assert len(trn_series) == len(target)
    assert trn_series.name == tst_series.name
    temp = pd.concat([trn_series, target], axis=1)
    # Compute target mean 
    averages = temp.groupby(by=trn_series.name)[target.name].agg(["mean", "count"])
    # Compute smoothing
    smoothing = 1 / (1 + np.exp(-(averages["count"] - min_samples_leaf) / smoothing))
    # Apply average function to all target data
    prior = target.mean()
    # The bigger the count the less full_avg is taken into account
    averages[target.name] = prior * (1 - smoothing) + averages["mean"] * smoothing
    averages.drop(["mean", "count"], axis=1, inplace=True)
    # Apply averages to trn and tst series
    ft_trn_series = pd.merge(
        trn_series.to_frame(trn_series.name),
        averages.reset_index().rename(columns={'index': target.name, target.name: 'average'}),
        on=trn_series.name,
        how='left')['average'].rename(trn_series.name + '_mean').fillna(prior)
    # pd.merge does not keep the index so restore it
    ft_trn_series.index = trn_series.index 
    ft_tst_series = pd.merge(
        tst_series.to_frame(tst_series.name),
        averages.reset_index().rename(columns={'index': target.name, target.name: 'average'}),
        on=tst_series.name,
        how='left')['average'].rename(trn_series.name + '_mean').fillna(prior)
    # pd.merge does not keep the index so restore it
    ft_tst_series.index = tst_series.index
    return add_noise(ft_trn_series, noise_level), add_noise(ft_tst_series, noise_level)

def print_warning(input_string, symbol='*'):
    assert isinstance(input_string, str) and isinstance(symbol, str), \
           TypeError('Illegal input formats.')
    print(symbol * len(input_string))
    print(input_string)
    print(symbol * len(input_string))

@contextmanager
def timer(title=None):
    if title is not None:
        assert isinstance(title, str), 'Title can only be strings.'
    else:
        title = 'THIS CHUCK OF CODES'

    _tic = time.time()
    yield
    gc.collect()
    _lag = time.time() - _tic

    if _lag <= 60:
        _unit = 'second(s)'
    elif (_lag > 60) & (_lag <= 3600):
        _unit = 'minute(s)'
        _lag /= 60
    else:
        _unit = 'hour(s)'
        _lag /= 3600

    print_warning('For {}, time cost: {:.2f} {}'.format(title.lower(), _lag, _unit))